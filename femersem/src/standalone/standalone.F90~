#include "cppdefs.h"
!-----------------------------------------------------------------------
!BOP
!
! !MODULE: standalone
!
! !INTERFACE:
   module standalone
!
! !DESCRIPTION:
! This module contains all the routines for the standard BFM
! simulation in standalone version, i.e. with a 0.5D setup
! (pelagic and benthic).
! It also contains all the ancillary functions for forcing functions.
!
! !USES:
!  default: all is private.
   use global_mem, only:RLEN
   use constants,  only:SEC_PER_DAY
   private
!
! !PUBLIC MEMBER FUNCTIONS:
   public envforcing_bfm,timestepping,init_standalone
   public temperature,salinity,light,lightAtTime,daylength,instLight
   public time_manager,bfm_to_hydro,hydro_to_bfm
! !PUBLIC DATA MEMBERS:
   ! Note: all read from namelist
   !---------------------------------------------
   ! geographic and dimensional parameters
   !---------------------------------------------
   real(RLEN),public        :: latitude,longitude
   integer, public          :: nboxes
   real(RLEN),public        :: indepth
   !---------------------------------------------
   ! timestepping parameters
   ! real:
   ! mindelt: minimal time step allowed for computation
   ! endtim: endtime of integration
   ! time: actual time
   ! delt: actual time step of global integration
   ! maxdelt: maximal timestep
   !---------------------------------------------
   real(RLEN),public  :: maxdelt,mindelt,endtim, &
                         timesec,delt
   !---------------------------------------------
   ! integer:
   ! nmaxdelt: number of mindelts in maxdelts
   ! nendtim: number of total maxelts to endtim
   ! nmin: actual no. of mindelts in maxdelt intervall
   ! nstep: actual time step in mindelts
   ! ntime: actual time in maxdelts
   ! method: integration method
   !---------------------------------------------
   integer,public     :: nmaxdelt,nendtim,nmin,nstep,ntime, &
                         method
   !---------------------------------------------
   ! forcing function parameters
   !---------------------------------------------
   real(RLEN), public :: tw,ts,tde,sw,ss,lw,ls
   real(RLEN), public :: botdep_c,botdep_n,botdep_p,botdep_si,botox_o
   !---------------------------------------------
   ! arrays for integration routines
   !---------------------------------------------
   real(RLEN),public,dimension(:,:),allocatable :: bbccc3D,bccc3D,ccc_tmp3D
   real(RLEN),public,dimension(:,:),allocatable :: bbccc2D,bccc2D,ccc_tmp2D
   real(RLEN),public                            :: dtm1
   logical,public                               :: sspflag

!
! !PRIVATE DATA MEMBERS:
   real(RLEN),parameter :: PI=3.14159265,RFACTOR=PI/180.
   integer,parameter    :: namlst=10,unit=11

   REALTYPE,dimension(:),allocatable :: cdepth
!
! !REVISION HISTORY:
!  Original author(s): Marcello Vichi (INGV), Momme Buthenschoen (UNIBO)
!
!  $Log: $
!EOP
!-----------------------------------------------------------------------

   contains

!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE: Initialise the standalone BFM
!
! !INTERFACE:
   subroutine init_standalone()
!
! !DESCRIPTION:
!  Main communication of array dimensions between
!  BFM and the standalone setup
!  Read also integration limits
!
!
! !USES:
   use mem, only: NO_D3_BOX_STATES, NO_BOXES,          &
                  NO_BOXES_X, NO_BOXES_Y, NO_BOXES_Z,  &
                  NO_D2_BOX_STATES, NO_BOXES_XY,       &
                  NO_D2_BOX_DIAGNOSS, NO_D3_BOX_DIAGNOSS,&
                  NO_STATES,Depth,Depth_ben, D3STATE, D2STATE
   use global_mem, only:RLEN,LOGUNIT,NML_OPEN,NML_READ,error_msg_prn
   use api_bfm
   use netcdf_bfm, only: init_netcdf_bfm,init_save_bfm
   use time
   
   IMPLICIT NONE
   include '../../../fem3d/param.h'
!
! !INPUT PARAMETERS:
!
! !REVISION HISTORY:
!  Original author(s): Marcello Vichi
!
! !LOCAL VARIABLES:
   namelist /standalone_nml/mindelt,method,latitude,longitude
   namelist /anforcings_nml/tde,botdep_c,botdep_n,botdep_p,botdep_si,botox_o
   namelist /time_nml/ timefmt,MaxN,start,stop,simdays
!
! !LOCAL VARIABLES:
   real(RLEN) :: tt
   integer    :: dtm1,i

! HYDROCODE DATA
  integer nkn,nel,nrz,nrq,nrb,nbc,ngr,mbw
  common /nkonst/ nkn,nel,nrz,nrq,nrb,nbc,ngr,mbw
  real drr
  common /drr/drr
  real hkv(nkndim)
  common /hkv/hkv

  integer itanf,itend,idt,nits,niter,it
  common /femtim/ itanf,itend,idt,nits,niter,it




!EOP
!-----------------------------------------------------------------------
!BOC
   LEVEL2 'init_standalone'
   !---------------------------------------------
   ! Give initial default values
   ! (overwritten with namelist)
   !---------------------------------------------
   nboxes      = 1 ! real data from model
   indepth     = 10.0  !fake data from model
   latitude    = 0.0 !fake from nml
   longitude   = 0.0 !fake from nml
   maxdelt     = 100.0 !fake 
   mindelt     = 1.0 !realdata from str
   endtim      = 360.0 !fake 
   method      = 1 !real from str
  !anforcings
   lw          = 9.0 !fake from model
   ls          = 11.0 !fake "
   sw          = 33.0 !fake "
   ss          = 37.0 !fake "
   tw          = 10.0 !fake "
   ts          = 25.0 !fake "
   tde         = 1.0 !fake "
   botdep_c    = 0.0 !real "
   botdep_n    = 0.0 !real "
   botdep_p    = 0.0 !real "
   botdep_si   = 0.0 !real "
   botox_o     = 0.0 !real  from model
	
   print*,' 2 step '
	
   open(namlst,file='standalone.nml',status='old',action='read',err=100)
   read(namlst,nml=standalone_nml,err=101)
   close(namlst)
   open(namlst,file='standalone.nml',status='old',action='read',err=100)
   read(namlst,nml=anforcings_nml,err=102)
   close(namlst)
   open(namlst,file='standalone.nml',status='old',action='read',err=100)
   read(namlst,nml=time_nml,err=103)
   close(namlst)

! initialize state variables from fem3d
   maxdelt =drr
   nboxes = nkn
   !---------------------------------------------
   ! set the dimensions
   !---------------------------------------------
   NO_BOXES_X  = nboxes
   NO_BOXES_Y  = 1
   NO_BOXES_Z  = 1
   NO_BOXES    = NO_BOXES_X * NO_BOXES_Y * NO_BOXES_Z
   NO_BOXES_XY = NO_BOXES_X * NO_BOXES_Y
   NO_STATES   = NO_D3_BOX_STATES * NO_BOXES +   &
                 NO_D2_BOX_STATES * NO_BOXES_XY

   LEVEL3 'Number of Boxes:',NO_BOXES

   !---------------------------------------------
   ! initialise the timestepping parameters
   ! Use the GOTM time-manager
   ! Time is given in Julian day and seconds of day
   ! (both integer values)
   !---------------------------------------------
   timestep = maxdelt
   timesec=real(it)
   nmaxdelt=1
   LEVEL3 'nmaxdelt: ',nmaxdelt
   tt=maxdelt/2.
   do while (tt.ge.mindelt)
      tt=tt/2.
      nmaxdelt=nmaxdelt*2
      LEVEL3 'nmaxdelt: ',nmaxdelt
   end do
   mindelt=maxdelt/nmaxdelt ! maxdelt = nmaxdelt*mindelt
   nstep=nmaxdelt
   ntime=0
   nmin=0
   dtm1=maxdelt
   delt=maxdelt
   if (method.eq.3) delt=2*delt
   LEVEL3 'Integration method: ',method
   LEVEL3 'maxdelt (sec): ',maxdelt
   LEVEL3 'mindelt (sec): ',mindelt
   LEVEL3 'nmaxdelt: ',nmaxdelt
   LEVEL3 'Initial time (sec): ',timesec

   !---------------------------------------------
   ! Initialise the BFM with standalone settings
   !---------------------------------------------
   call init_bfm(namlst)
   !---------------------------------------------
   ! Initialise state variable names and diagnostics
   !---------------------------------------------
   call set_var_info_bfm
   !---------------------------------------------
   ! Allocate memory and give initial values
   !---------------------------------------------
   ! the argument list is kept for compatibility with GOTM
   call init_var_bfm(namlst,'bfm.nml',unit,bio_setup)
   !---------------------------------------------
   ! Initialize depth 
   !---------------------------------------------
    Depth(:)=hkv(1:NO_BOXES)
    Depth_ben(:)=Depth(:)
!   LEVEL3 'Box Depth:',Depth,Depth_ben
   !---------------------------------------------
   ! initialise netcdf output
   !---------------------------------------------
   call calcmean_bfm(INIT)
   call init_netcdf_bfm(out_title,'01-01-0000',0,  &
             lat=latitude,lon=longitude,z=Depth,   &
             oceanpoint=(/(i,i=1,NO_BOXES)/),      &
             surfacepoint=(/(i,i=1,NO_BOXES_XY)/), &
             bottompoint=(/(i,i=1,NO_BOXES_XY)/))
   call init_save_bfm
   !---------------------------------------------
   ! allocate and initialise integration arrays
   !---------------------------------------------
   allocate(bbccc3D(NO_D3_BOX_STATES,NO_BOXES))
   allocate(bccc3D(NO_D3_BOX_STATES,NO_BOXES))
   allocate(ccc_tmp3D(NO_D3_BOX_STATES,NO_BOXES))
   allocate(bbccc2D(NO_D2_BOX_STATES,NO_BOXES))
   allocate(bccc2D(NO_D2_BOX_STATES,NO_BOXES))
   allocate(ccc_tmp2D(NO_D2_BOX_STATES,NO_BOXES))
   ! Initialize prior time step for leap-frog:
   if (method == 3) then
      bbccc3d = D3STATE
      bbccc2d = D2STATE
      ccc_tmp3D = D3STATE
      ccc_tmp2D = D3STATE
   end if
   return

100   call error_msg_prn(NML_OPEN,"standalone.f90","standalone.nml")
101   call error_msg_prn(NML_READ,"standalone.f90","standalone_nml")
102   call error_msg_prn(NML_READ,"standalone.f90","anforcings_nml")
103   call error_msg_prn(NML_READ,"standalone.f90","time_nml")

   end subroutine init_standalone
!EOC
!-----------------------------------
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE: Light and other environmental forcings used in the BFM
!
! !INTERFACE
   subroutine envforcing_bfm()
!
! !DESCRIPTION
!
! !USES
   use api_bfm
   use global_mem, only: RLEN
   use mem,        only: ETW,ESW,EIR,ESS,SUNQ,ThereIsLight, &
                         rutQ6c,rutQ6n,rutQ6p,rutQ6s,R6c,R6n,R6p,R6s,O2o,&
			 Depth,Depth_ben
   use mem_Param,  only: LightForcingFlag,p_PAR
   IMPLICIT NONE
   include '../../../fem3d/param.h'
!
! !INPUT PARAMETERS:
!
! !OUTPUT PARAMETERS:
!
! !REVISION HISTORY:
!  Original author(s): Momme Butenschoen (UNIBO)
!
! !LOCAL VARIABLES:
   real(RLEN) :: dfrac,wlight,dtime
   integer    :: dyear
   real(RLEN),external :: GetDelta
   real(RLEN) :: biodelta

!  ENVFORCING FROM HYDRO

   integer nkn,nel,nrz,nrq,nrb,nbc,ngr,mbw
   common /nkonst/ nkn,nel,nrz,nrq,nrb,nbc,ngr,mbw

   real tempv(nlvdim,nkndim)
   common /tempv/tempv

   real saltv(nlvdim,nkndim)
   common /saltv/saltv

   real ddepth(nlvdim,nkndim)
   common /ddepth/ddepth

!EOP
!-----------------------------------------------------------------------
!BOC
#ifdef DEBUG
   LEVEL1 'envforcing_bfm'
   LEVEL2 'time=',timesec
#endif
   !---------------------------------------------
   ! Computes all the forcings
   !---------------------------------------------
   dtime = timesec/SEC_PER_DAY
   sunq=daylength(dtime,latitude)
   dfrac=(dtime-floor(dtime)) ! fraction of the day
   dyear=mod(dtime,360.) ! Day of the year
   wlight=light(dyear,dfrac)
   select case(LightForcingFlag)
    case (3) ! light on/off distribution for daylight average
      ThereIsLight=lightAtTime(dfrac,sunq)
      wlight=wlight*ThereIsLight
    case (1) ! instantaneous light distribution
      wlight=instLight(wlight,sunq,dfrac)
    case default ! light constant during the day
   end select
!   ESS = 0.
!   ETW = temperature(dyear,dfrac)
!   ESW = salinity(dyear,dfrac)
!   EIR = wlight*p_PAR
#ifdef DEBUG
   LEVEL2 'ETW=',ETW
   LEVEL2 'ESW=',ESW
   LEVEL2 'EIR=',EIR
#endif
	
! feeding envforcing vector from HYDROcode

   ETW(:)=tempv(1,1:nkn)
   ESW(:)=saltv(1,1:nkn)
   EIR(:)=wlight*p_PAR   ! to be changed 
   ESS(:)=0.
   Depth(:)=ddepth(1,1:nkn)
   Depth_ben(:)=Depth(:)


   call CalcVerticalExtinction

   if (bio_setup==2) then
      ! Bottom deposition and ventilation fluxes
      ! (mg C m^-2 d^-1 or mmol NUT m^-2 d^-1)
      ! currently constant deposition rates read from namelist
      ! (se to zero for no deposition)
      biodelta=GetDelta()
      R6c(:) = R6c(:)+botdep_c*biodelta
      R6n(:) = R6n(:)+botdep_n*biodelta
      R6p(:) = R6p(:)+botdep_p*biodelta
      R6s(:) = R6s(:)+botdep_si*biodelta
      O2o(:) = O2o(:)+botox_o*biodelta
   end if

   end subroutine envforcing_bfm
!EOC

!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE:
!
! !INTERFACE:
   FUNCTION daylength(time,latitude)
!
! !DESCRIPTION:
! This function computes the length of the daylight period in hours
! as a function of time of the year (days) and latitude
!
! !USES:
   use global_mem, only:RLEN
   IMPLICIT NONE
!
! !INPUT PARAMETERS:
   real(RLEN),intent(in) :: time
   real(RLEN),intent(in) :: latitude
!
! !INPUT/OUTPUT PARAMETERS:

!
! !OUTPUT PARAMETERS:
   real(RLEN) :: daylength
!
! !REVISION HISTORY:
!  Author(s): Momme Butenschoen (UNIBO)
!
! !LOCAL VARIABLES:
   real(RLEN)           :: declination
   real(RLEN),parameter :: cycle=360.
!
!EOP
!-----------------------------------------------------------------------
!BOC
   declination = -0.406*cos(2.*PI*int(time)/cycle)
   daylength = acos(-tan(declination)*tan(latitude*RFACTOR))/PI*24.
   return

   END FUNCTION daylength
!EOC

!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE:
!
! !INTERFACE:
   FUNCTION lightAtTime(df,dl)
!
! !DESCRIPTION:
!  This function determines whether there is light at a certain time
!  of the day. Returns an integer value 0 or 1
!
! !USES:
   use global_mem, only:RLEN
   IMPLICIT NONE
!
! !INPUT PARAMETERS:
 real(RLEN),intent(in) :: df,dl

!
! !INPUT/OUTPUT PARAMETERS:

!
! !OUTPUT PARAMETERS:
 integer :: lightAtTime

!
! !REVISION HISTORY:
!  Author(s): Momme Butenschoen (UNIBO)
!
! !LOCAL VARIABLES:
 real(RLEN) :: daytime,daylength
!
!EOP
!-----------------------------------------------------------------------
!BOC
    daytime=df*24. ! time of the day = fraction of the day * 24
    daytime=abs(daytime-12.) ! distance from noon
    daylength=dl/2.
    if(daytime.lt.daylength) then
      lightAtTime=1
    else
      lightAtTime=0
    endif
    return
   END FUNCTION lightAtTime
!EOC

!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE:
!
! !INTERFACE:
   FUNCTION instLight(l,dl,df)
!
! !DESCRIPTION:
!  This function computes the instantaneous light at a certain time of
!  the day
!
! !USES:
   use global_mem, only:RLEN
   IMPLICIT NONE
!
! !INPUT PARAMETERS:
   real(RLEN),intent(in) :: df,dl,l
!
! !INPUT/OUTPUT PARAMETERS:

!
! !OUTPUT PARAMETERS:
   real(RLEN) :: instLight
!
! !REVISION HISTORY:
!  Author(s): Momme Butenschoen (UNIBO)
!
! !LOCAL VARIABLES:
   real(RLEN) :: daylength,daytime
!
!EOP
!-----------------------------------------------------------------------
!BOC
     daytime=df*24. ! time of the day = fraction of the day * 24
     daytime=abs(daytime-12.) ! distance from noon
     daylength=dl/2.
     if(daytime.lt.daylength) then
       daytime=daytime/daylength*PI
       instLight=l*cos(daytime)+l
     else
       instLight=0.
     endif
     return
   END FUNCTION instLight
!EOC

!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE:
!
! !INTERFACE:
   FUNCTION salinity(dy,df)
!
! !DESCRIPTION:
!  This function provides an articial salinity value given the
!  parameters in the standalone.nml namelist
!
! !USES:
   use global_mem, only:RLEN
   IMPLICIT NONE
!
! !INPUT PARAMETERS:
   integer,intent(in)    :: dy
   real(RLEN),intent(in) :: df
!
!
! !INPUT/OUTPUT PARAMETERS:

!
! !OUTPUT PARAMETERS:
   real(RLEN) :: salinity

!
! !REVISION HISTORY:
!  Author(s): Momme Butenschoen (UNIBO)
!
! !LOCAL VARIABLES:

!
!EOP
!-----------------------------------------------------------------------
!BOC
     salinity=(ss+sw)/2.-(ss-sw)/2.*cos((dy+(df-.5))*RFACTOR)
   END FUNCTION salinity
!EOC

!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE:
!
! !INTERFACE:
   FUNCTION temperature(dy,df)
!
! !DESCRIPTION:
!  This function provides an articial temperature value given the
!  parameters in the standalone.nml namelist
!
! !USES:
   use global_mem, only:RLEN
   IMPLICIT NONE
!
! !INPUT PARAMETERS:
   integer,intent(in)    :: dy
   real(RLEN),intent(in) :: df
!
!
! !INPUT/OUTPUT PARAMETERS:

!
! !OUTPUT PARAMETERS:
   real(RLEN) :: temperature

!
! !REVISION HISTORY:
!  Author(s): Momme Butenschoen (UNIBO)
!
! !LOCAL VARIABLES:

!
!EOP
!-----------------------------------------------------------------------
!BOC
     temperature=(ts+tw)/2.-(ts-tw)/2.*cos((dy+(df-.5))*RFACTOR) &
                    -tde*.5*cos(2*Pi*df)
   END FUNCTION temperature
!EOC

!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE:
!
! !INTERFACE:
   FUNCTION light(dy,df)
!
! !DESCRIPTION:
!  This function provides an articial light value given the
!  parameters in the standalone.nml namelist
!
! !USES:
   use global_mem, only:RLEN
   IMPLICIT NONE
! !INPUT PARAMETERS:
   integer,intent(in)    :: dy
   real(RLEN),intent(in) :: df
! !INPUT/OUTPUT PARAMETERS:
!
! !OUTPUT PARAMETERS:
   real(RLEN) :: light
! !REVISION HISTORY:
!  Author(s): Momme Butenschoen (UNIBO)
!
! !LOCAL VARIABLES:
!
!EOP
!-----------------------------------------------------------------------
!BOC
     light=(ls+lw)/2.-(ls-lw)/2.*cos(dy*RFACTOR)
   END FUNCTION light
!EOC


!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE:
!
! !INTERFACE:
   SUBROUTINE timestepping()
!
! !DESCRIPTION:
!
!
! !USES:
   use global_mem, only:RLEN
   use netcdf_bfm, only: save_bfm
   use mem
   use api_bfm, only: out_delta
   IMPLICIT NONE

! !INPUT PARAMETERS:
! !INPUT/OUTPUT PARAMETERS:
!
! !OUTPUT PARAMETERS:
! !REVISION HISTORY:
!  Author(s): Momme Butenschoen (UNIBO)
!
! !LOCAL VARIABLES:

!
!EOP
!-----------------------------------------------------------------------
!BOC

!   LEVEL1 'timestepping'

!  do while (ntime.le.nendtim)
#ifdef DEBUG
      LEVEL2 'ntime=',ntime
#endif
      call envforcing_bfm
      call EcologyDynamics
      print*,timesec
      select case (method)
         case (2)
            call integrationRK2
         case (3)
            call integrationLf
         case default
            call integrationEfw
      end select
      call calcmean_bfm(ACCUMULATE)
      if (mod(ntime,out_delta).eq.0) then
         LEVEL1 'OUTPUT' , timesec/SEC_PER_DAY
         call calcmean_bfm(MEAN)
         call save_bfm(timesec)
      end if
       print*,NO_D3_BOX_STATES,O2o
       print*,NO_D3_BOX_STATES,P1c
      call ResetFluxes
!  end do

   END SUBROUTINE timestepping
!EOC
!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE: Providing info on variables
!
! !INTERFACE:

   subroutine time_manager
  
   !---------------------------------------------
   ! manage the timestepping parameters
   !---------------------------------------------
  
 
   use mem
   use time
   use global_mem, only:RLEN
	
   IMPLICIT NONE
   
   integer itanf,itend,idt,nits,niter,it
   common /femtim/ itanf,itend,idt,nits,niter,it

   real drr
   common /drr/drr

   real(RLEN) :: tt
   integer    :: dtm1,i
   
   maxdelt =drr
   timestep = maxdelt
   nmaxdelt=1
   tt=maxdelt/2.
   do while (tt.ge.mindelt)
      tt=tt/2.
      nmaxdelt=nmaxdelt*2
       LEVEL3 'nmaxdelt: ',nmaxdelt,maxdelt
   end do
   mindelt=maxdelt/nmaxdelt ! maxdelt = nmaxdelt*mindelt
   nstep=nmaxdelt
   nmin=0
   dtm1=maxdelt
   delt=maxdelt

   timesec = it


   end subroutine time_manager

!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE: Providing info on variables
!
! !INTERFACE:

   subroutine bfm_to_hydro(b1cn,nbfmv1,b2cn,nbfmv2,b3cn,nbfmv3)

   use mem
   implicit  none

   include '../../../fem3d/param.h'
   include '../../../fem3d/bfm_common.h'
   integer nkn,nel,nrz,nrq,nrb,nbc,ngr,mbw
   integer nlvdi,nlv
   common /nkonst/ nkn,nel,nrz,nrq,nrb,nbc,ngr,mbw
   common /level/ nlvdi,nlv


   integer l,k

	 integer nbfmv1,nbfmv2,nbfmv3
        double precision b1cn(nlvdim,nkndim,nbfmv1)
        double precision b2cn(nlvdim,nkndim,nbfmv2)
        double precision b3cn(nlvdim,nkndim,nbfmv3)


   
    do k=1,nkn
     
	   fO2o(k)=  O2o(k)
           fN1p(k)=  N1p(k)
           fN3n(k)=  N3n(k)
           fN4n(k)=  N4n(k)
           fO4n(k)=  O4n(k)
           fN5s(k)=  N5s(k)
           fN6r(k)=  N6r(k)
           fB1c(k)=  B1c(k)
           fB1n(k)=  B1n(k)
           fB1p(k)=  B1p(k)
           fP1c(k)=  P1c(k)
           fP1n(k)=  P1n(k)
           fP1p(k)=  P1p(k)
           fP1l(k)=  P1l(k)
           fP1s(k)=  P1s(k)
           fP2c(k)=  P2c(k)
           fP2n(k)=  P2n(k)
           fP2p(k)=  P2p(k)
           fP2l(k)=  P2l(k)
           fP3c(k)=  P3c(k)
           fP3n(k)=  P3n(k)
           fP3p(k)=  P3p(k)
           fP3l(k)=  P3l(k)
           fP4c(k)=  P4c(k)
           fP4n(k)=  P4n(k)
           fP4p(k)=  P4p(k)
           fP4l(k)=  P4l(k)
           fZ3c(k)=  Z3c(k)
           fZ3n(k)=  Z3n(k)
           fZ3p(k)=  Z3p(k)
           fZ4c(k)=  Z4c(k)
           fZ4n(k)=  Z4n(k)
           fZ4p(k)=  Z4p(k)
           fZ5c(k)=  Z5c(k)
           fZ5n(k)=  Z5n(k)
           fZ5p(k)=  Z5p(k)
           fZ6c(k)=  Z6c(k)
           fZ6n(k)=  Z6n(k)
           fZ6p(k)=  Z6p(k)
           fR1c(k)=  R1c(k)
           fR1n(k)=  R1n(k)
           fR1p(k)=  R1p(k)
           fR2c(k)=  R2c(k)
           fR6c(k)=  R6c(k)
           fR6n(k)=  R6n(k)
           fR6p(k)=  R6p(k)
           fR6s(k)=  R6s(k)
           fR7c(k)=  R7c(k)   
	do l=1,nlv
	  b1cn(l,k,1) = O2o(k)
          b1cn(l,k,2) = N1p(k) 
          b1cn(l,k,3) = N3n(k) 
          b1cn(l,k,4) = N4n(k) 
          b1cn(l,k,5) = O4n(k) 
          b1cn(l,k,6) = N5s(k) 
          b1cn(l,k,7) = N6r(k) 
          b2cn(l,k,1) = B1c(k) 
          b2cn(l,k,2) = P1c(k) 
          b2cn(l,k,3)= P2c(k) 
          b2cn(l,k,4)= P3c(k) 
          b2cn(l,k,5)= P4c(k) 
          b2cn(l,k,6)= Z3c(k) 
          b2cn(l,k,7)= Z4c(k) 
          b2cn(l,k,8)= Z5c(k) 
          b2cn(l,k,9)= Z6c(k) 
          b3cn(l,k,1)= R1c(k) 
          b3cn(l,k,2)= R2c(k) 
          b3cn(l,k,3)= R6c(k) 
          b3cn(l,k,4)= R7c(k) 

	                                              
        end do                        
   end do                             
                                      
                                      
                                      
   end subroutine bfm_to_hydro        
!EOC                                  
!-----------------------------------------------------------------------
!BOP                                  
!                                     
! !IROUTINE: Providing info on variables
!                                     
! !INTERFACE:                         

   subroutine hydro_to_bfm(b1cn,nbfmv1,b2cn,nbfmv2,b3cn,nbfmv3)
   use global_mem
   use mem
   implicit  none

   include '../../../fem3d/param.h'
   
   integer nkn,nel,nrz,nrq,nrb,nbc,ngr,mbw
   integer nlvdi,nlv
   common /nkonst/ nkn,nel,nrz,nrq,nrb,nbc,ngr,mbw
   common /level/ nlvdi,nlv

	integer nbfmv1,nbfmv2,nbfmv3
        double precision b1cn(nlvdim,nkndim,nbfmv1)
        double precision b2cn(nlvdim,nkndim,nbfmv2)
        double precision b3cn(nlvdim,nkndim,nbfmv3)

   integer l,k

   
    do k=1,nkn
     do l=1,nlv
	  O2o(k)  =b1cn(l,k,1)
          N1p(k)  =b1cn(l,k,2)
          N3n(k)  =b1cn(l,k,3)
          N4n(k)  =b1cn(l,k,4)
          O4n(k)  =b1cn(l,k,5)
          N5s(k)  =b1cn(l,k,6)
          N6r(k)  =b1cn(l,k,7)
          B1c(k)  =b2cn(l,k,1)
          P1c(k)  =b2cn(l,k,2)
          P2c(k)  =b2cn(l,k,3)
          P3c(k)  =b2cn(l,k,4)
          P4c(k)  =b2cn(l,k,5)
          Z3c(k)  =b2cn(l,k,6)
          Z4c(k)  =b2cn(l,k,7)
          Z5c(k)  =b2cn(l,k,8)
          Z6c(k)  =b2cn(l,k,9)
          R1c(k)  =b3cn(l,k,1)
          R2c(k)  =b3cn(l,k,2)
          R6c(k)  =b3cn(l,k,3)
          R7c(k)  =b3cn(l,k,4)
        end do
   end do


   end subroutine hydro_to_bfm
!EOC
!
   END MODULE standalone

