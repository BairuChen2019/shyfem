c
c $Id: newbcl.F,v 1.9 2001/01/15 14:03:36 georg Exp $
c
c baroclinic routines
c
c contents :
c
c subroutine barocl(mode)		amministrates the baroclinic time step
c subroutine rhoset			computes rhov and bpresv
c subroutine bclint			integration of baroclinic components
c
c revision log :
c
c revised 30.08.95	$$AUST - austausch coefficient introduced
c revised 11.10.95	$$BCLBND - boundary condition for barocliic runs
c 19.08.1998    ggu     call to barcfi changed
c 20.08.1998    ggu     can initialize S/T from file
c 24.08.1998    ggu     levdbg used for debug
c 26.08.1998    ggu     init, bnd and file routines substituted with con..
c 30.01.2001    ggu     eliminated compile directives
c
c*****************************************************************

	subroutine barocl(mode)

c amministrates the baroclinic time step
c
c mode : =0 initialize  >0 normal call
c
c written 09.01.94 by ggu  (from scratch)
c
	implicit none
c
c parameter
	include 'param.h'
c arguments
	integer mode
c common
        integer nkn,nel,nrz,nrq,nrb,nbc,ngr,mbw
        integer itanf,itend,idt,nits,niter,it
        real grav,fcor,dcor,dirn,rowass,roluft
        integer nlvdi,nlv
	real saltv(nlvdim,1),tempv(nlvdim,1),rhov(nlvdim,1)
	real bpresv(nlvdim,1)
	real saux1(nlvdim,1),saux2(nlvdim,1)
	real saux3(nlvdim,1),saux4(nlvdim,1)
	real uprv(nlvdim,1), vprv(nlvdim,1)
	real hlv(1),hldv(1)
	real v1v(1)
	real rsv(1), rtv(1)				!$$BCLBND
	integer ilhkv(1)
        common /nkonst/ nkn,nel,nrz,nrq,nrb,nbc,ngr,mbw
        common /femtim/ itanf,itend,idt,nits,niter,it
        common /pkonst/ grav,fcor,dcor,dirn,rowass,roluft
        common /level/ nlvdi,nlv
	common /saltv/saltv, /tempv/tempv, /rhov/rhov
	common /bpresv/bpresv
	common /saux1/saux1, /saux2/saux2
	common /saux3/saux3, /saux4/saux4
	common /uprv/uprv, /vprv/vprv
	common /hlv/hlv, /ilhkv/ilhkv, /hldv/hldv
	common /v1v/v1v
	common /rsv/rsv, /rtv/rtv			!$$BCLBND
	real zeov(3,1), zenv(3,1)
	common /zeov/zeov, /zenv/zenv
	real difv(0:nlvdim,1)
	common /difv/difv
c local
	logical debug
	logical badvect
	integer levdbg
	integer ie
	integer icall
	integer ibarcl
	integer istot,idtext,itmext
	integer imin,imax
	real xmin,xmax
	real salref,temref,sstrat,tstrat
	real shpar,thpar
	real azpar,adpar,aapar
	real difmol
	real dt
	integer isact,l,k,lmax
	integer kspec
	real smin,smax,tmin,tmax,rmin,rmax
	double precision v1,v2,mm
c functions
c	real sigma
	real getpar
	integer iround
c save
        integer iu,itmcon,idtcon
        save iu,itmcon,idtcon

	save badvect
	save salref,temref
	save shpar,thpar
	save difmol
	save azpar,adpar,aapar
	save dt
	save istot
	save icall
c data
	data icall /0/

	if(nlvdim.ne.nlvdi) stop 'error stop : level dimension in barocl'

	if(icall.eq.-1) return

	levdbg = nint(getpar('levdbg'))
	debug = levdbg .ge. 3

c initialization

	if(icall.eq.0) then	!first time

		ibarcl=iround(getpar('ibarcl'))
		if(ibarcl.le.0) icall = -1
		if(icall.eq.-1) return

		badvect = ibarcl .eq. 1 .or. ibarcl .eq. 3

		salref=getpar('salref')
		temref=getpar('temref')
		sstrat=getpar('sstrat')
		tstrat=getpar('tstrat')
		shpar=getpar('shpar')
		thpar=getpar('thpar')
		azpar=getpar('azpar')
		adpar=getpar('adpar')
		aapar=getpar('aapar')
		difmol=getpar('difmol')
		istot=iround(getpar('istot'))
		idtcon=iround(getpar('idtcon'))
		itmcon=iround(getpar('itmcon'))
		dt=idt

c		initialize saltv,tempv

		call conini(nlvdi,saltv,salref,sstrat)
		call conini(nlvdi,tempv,temref,tstrat)

c		initialization from file (if any)

		call inicfil('salt',saltv)
		call inicfil('temp',tempv)

c		initialize rhov, bpresv (we call it twice since
c		rhov depends on bpresv and viceversa
c		-> we iterate to the real solution)

		call rhoset
		call rhoset

		call qfluxr(it)

        	iu = 55
        	itmcon = iround(getpar('itmcon'))
        	idtcon = iround(getpar('idtcon'))
        	call confop(iu,itmcon,idtcon,2,'nos')

	end if

	icall=icall+1

	if(mode.eq.0) return

c salt and temperature transport & diffusion

	if( badvect ) then

	do isact=1,istot
	  call tsmass(saltv,zeov,nlvdim,smin) 
	  call conz3d(saltv,saux1,saux2,saux3,saux4,dt,shpar,difv
     +		,difmol,azpar,adpar,aapar,istot,isact,nlvdi,nlv)
	  call tsmass(saltv,zenv,nlvdim,smax) 
	  call conz3d(tempv,saux1,saux2,saux3,saux4,dt,thpar,difv
     +		,difmol,azpar,adpar,aapar,istot,isact,nlvdi,nlv)
	  if( debug ) write(6,*) 'total mass S/S: ',smin,smax

c	  boundary conditions...		!$$BCLBND

c	  call conbnd(nlvdi,saltv,rsv)
c	  call conbnd(nlvdi,tempv,rtv)

	  call bndo_setbc(it,'temp',nlvdi,tempv,uprv,vprv)
	  call bndo_setbc(it,'salt',nlvdi,saltv,uprv,vprv)
	end do

	end if

c compute total mass

	if( debug ) then
	  call tsmass(saltv,zenv,nlvdim,smax) 
	  call tsmass(tempv,zenv,nlvdim,tmax) 
	  write(6,*) 'total mass T/S: ',tmax,smax
	end if

cccccccccccccccc

	call qfluxr(it)
	call qflux3d(it,idt,nkn,nlvdim,tempv)

c debug and test

	kspec = 253
	kspec = 0
        if( kspec .gt. 0 ) then
        !write(6,*) 'ATTENTION: in barocl homogenizing S/T/rho/bpresv'
        !write(6,*) 'ATTENTION: in barocl homogenizing S/T before rho'
        write(6,*) 'ATTENTION: in barocl homogenizing T before rho'
        do k=1,nkn
          lmax = ilhkv(k)
          do l=1,lmax
            tempv(l,k)  = tempv(l,kspec)
            !saltv(l,k)  = saltv(l,kspec)
            !rhov(l,k)   = rhov(l,kspec)
            !bpresv(l,k) = bpresv(l,kspec)
          end do
        end do
        end if

c compute rhov and bpresv

	call rhoset

c min/max

	call stmima(saltv,nkn,nlvdi,ilhkv,smin,smax)
	call stmima(tempv,nkn,nlvdi,ilhkv,tmin,tmax)
	call stmima(rhov,nkn,nlvdi,ilhkv,rmin,rmax)

c print of results

	call confil(iu,itmcon,idtcon,11,nlvdi,saltv)
	call confil(iu,itmcon,idtcon,12,nlvdi,tempv)

	end

c********************************************************

	subroutine rhoset
c
c computes rhov and bpresv
c
c 1 bar = 100 kPascal ==> factor 1.e-5
c pres = rho0*g*(zeta-z) + bpresv
c with bpresv = int_{z}^{zeta}(g*rho_prime)dz
c and rho_prime = rho - rho_0 = sigma - sigma_0
c
c in bpresv() is bpresv as defined above
c in rhov()   is rho_prime (=sigma_prime)
c
c brespv() and rhov() are given at node and layer interface

	implicit none

c parameter
	include 'param.h'
c common

        integer itanf,itend,idt,nits,niter,it
        common /femtim/ itanf,itend,idt,nits,niter,it

        integer nkn,nel,nrz,nrq,nrb,nbc,ngr,mbw
        real grav,fcor,dcor,dirn,rowass,roluft
        integer nlvdi,nlv
	real saltv(nlvdim,1),tempv(nlvdim,1)
	real bpresv(nlvdim,1),rhov(nlvdim,1)
	real hlv(1)
	real hldv(1)
	integer ilhkv(1)
        common /nkonst/ nkn,nel,nrz,nrq,nrb,nbc,ngr,mbw
        common /pkonst/ grav,fcor,dcor,dirn,rowass,roluft
        common /level/ nlvdi,nlv
	common /saltv/saltv, /tempv/tempv
	common /bpresv/bpresv, /rhov/rhov
	common /hlv/hlv
	common /hldv/hldv
	common /ilhkv/ilhkv
c local
	logical bdebug,debug
	integer k,l,lmax
	real sigma0,rho0,pres
	real depth,hlayer
	real rhop,presbt,presbc,dpresc
c functions
	real sigma

	rho0 = rowass
	sigma0 = rho0 - 1000.

	debug=.false.
	bdebug=.false.

	if(debug) write(6,*) sigma0,rowass,rho0

	do k=1,nkn
	  depth = 0.
	  presbc = 0.
	  lmax=ilhkv(k)

	  do l=1,lmax
	    hlayer = 0.5 * hldv(l)
	    depth = depth + hlayer
	    rhop = rhov(l,k)			!rho^prime

	    presbt = rho0 * grav * depth	!barotropic pressure
	    dpresc = rhop * grav * hlayer	!differential bc. pres.

	    pres = 1.e-5 * ( presbt + presbc + dpresc )
	    pres = 1.e-5 * presbt
	
	    rhop = sigma(saltv(l,k),tempv(l,k),pres) - sigma0

	    dpresc = rhop * grav * hlayer	!differential bc. pres.
	    presbc = presbc + dpresc            !baroclinic pres. (mid-layer)

	    rhov(l,k) = rhop
	    bpresv(l,k) = presbc

	    depth = depth + hlayer
	    presbc = presbc + dpresc		!baroclinic pres. (bottom-lay.)
	  end do
	end do

	return
	end

c******************************************************************
	
	subroutine bclint

c integration of baroclinic components -> baroxv & baroyv
c
c this is probably completely useless	!FIXME
c -> never called during new 3D routine
c
c       baroxv(ie) = baux	these arrays are not used
c       baroyv(ie) = caux	!FIXME -> remove arrays from ht and here
c       adauxv(ie) = baaux
c       adauyv(ie) = caaux
c
c written 17.10.94 by ggu  (from scratch)
c revised 08.03.95 by ggu  (devide by rho0 here)
c
	implicit none
c parameter
	include 'param.h'
c
	real drittl
	parameter (drittl=1./3.)
c arguments
c	integer mode
c common
	integer nkn,nel,nrz,nrq,nrb,nbc,ngr,mbw
        real grav,fcor,dcor,dirn,rowass,roluft
	integer nen3v(3,1),ilhv(1)
	real ev(13,1)
	real hldv(1),hlhv(1)
	real baroxv(1),baroyv(1)
	real adauxv(1),adauyv(1)
	real bpresv(nlvdim,1)
	real utlov(nlvdim,1),vtlov(nlvdim,1)
	real uprv(nlvdim,1),vprv(nlvdim,1)
        real saux1(nlvdim,1),saux2(nlvdim,1)
        real saux3(nlvdim,1),saux4(nlvdim,1)
        real austv(1)                                           !$$AUST
	common /nkonst/ nkn,nel,nrz,nrq,nrb,nbc,ngr,mbw
        common /pkonst/ grav,fcor,dcor,dirn,rowass,roluft
	common /nen3v/nen3v, /ilhv/ilhv
	common /ev/ev
	common /hldv/hldv, /hlhv/hlhv
	common /baroxv/baroxv, /baroyv/baroyv
	common /adauxv/adauxv, /adauyv/adauyv
	common /bpresv/bpresv
	common /utlov/utlov, /vtlov/vtlov
	common /uprv/uprv, /vprv/vprv
        common /saux1/saux1, /saux2/saux2
        common /saux3/saux3, /saux4/saux4
        common /austv/austv                                     !$$AUST

        real zeov(3,1),zenv(3,1)
        common /zeov/zeov, /zenv/zenv

c local
	logical bbaroc,badvec,baust
	integer ibarcl
	integer i,ie,l,lmax,ii
	integer k(3)
	real a(3),b(3),c(3)
	real uu(3),uv(3),vu(3),vv(3)
	real up,vp
	real dh
	real zm,rrho0
	real baux,caux
	real baaux,caaux
	real aust
	real hdep(nlvdim)
c functions
	integer iround
	real getpar

	badvec = iround(getpar('ilin'))   .eq. 0
	aust   = getpar('aust')					!$$AUST
	baust  = aust .gt. 0.
	ibarcl = iround(getpar('ibarcl'))
	bbaroc = ibarcl .ge. 1 .and. ibarcl .le. 2

	if( .not. badvec .and. .not. bbaroc .and. .not. baust ) return

	rrho0 = 1. / rowass
	if( .not. bbaroc ) rrho0 = 0.

c loop over elements

	do ie=1,nel

	zm=0.
	do i=1,3
	  k(i)=nen3v(i,ie)
	  zm=zm+zeov(i,ie)
	  b(i)=ev(i+3,ie)
	  c(i)=ev(i+6,ie)
	  a(i)=0.
	  uu(i)=0.
	  vu(i)=0.
	  uv(i)=0.
	  vv(i)=0.
	end do
	zm=zm*drittl

	lmax=ilhv(ie)

	do l=1,lmax
	  hdep(l) = hldv(l)
	end do
	hdep(lmax) = hlhv(ie)
	hdep(1) = hdep(1) + zm

c baroclinic contribution

	if( bbaroc ) then

	do l=1,lmax
	  do ii=1,3
	    a(ii) = a(ii) + hdep(l) * bpresv(l,k(ii))
	  end do
	end do

	end if

c advective contribution

	if( badvec ) then

	do l=1,lmax
	  dh = hdep(l)
	  do i=1,3
	    up = uprv(l,k(i))
	    vp = vprv(l,k(i))

	    uu(i) = uu(i) + up*up*dh		!$$UVPADV
	    vu(i) = vu(i) + vp*up*dh
	    uv(i) = uv(i) + up*vp*dh
	    vv(i) = vv(i) + vp*vp*dh

	  end do
	end do

	end if

c austausch contribution

	if( baust ) then				!$$AUST

	aust = austv(ie)

	do l=1,lmax
	  do i=1,3
	    uu(i) = uu(i) + aust*saux1(l,k(i))
	    vu(i) = vu(i) + aust*saux2(l,k(i))
	    uv(i) = uv(i) + aust*saux3(l,k(i))
	    vv(i) = vv(i) + aust*saux4(l,k(i))
	  end do
	end do

	end if

c integrate in element and write to array

	baux=0.
	caux=0.
	baaux=0.
	caaux=0.
	do ii=1,3
	  baux = baux   + b(ii) * rrho0 * a(ii)
	  caux = caux   + c(ii) * rrho0 * a(ii)
	  baaux = baaux + b(ii) * uu(ii) + c(ii) * vu(ii)
	  caaux = caaux + b(ii) * uv(ii) + c(ii) * vv(ii)
	end do

	baroxv(ie) = baux
	baroyv(ie) = caux
	adauxv(ie) = baaux
	adauyv(ie) = caaux

	end do

	return
	end

